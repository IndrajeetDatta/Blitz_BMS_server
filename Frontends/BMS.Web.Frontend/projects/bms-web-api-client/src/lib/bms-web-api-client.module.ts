//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export module BMSWebApiClientModule {
  export class BMSWebApiClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
      undefined;
    private http: {
      fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private readonly baseUrl: string;

    constructor(
      baseUrl?: string,
      http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
    ) {
      this.http = http ? http : (window as any);
      this.baseUrl =
        baseUrl !== undefined && baseUrl !== null
          ? baseUrl
          : 'http://localhost:3000';
    }

    /**
     * @return OK
     */
    getUsers(): Promise<ApplicationUser[]> {
      let url_ = this.baseUrl + '/users';
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetUsers(_response);
      });
    }

    /**
     * @param body (optional)
     * @return OK
     */
    createUsers(body: ApplicationUser | undefined): Promise<ApplicationUser> {
      let url_ = this.baseUrl + '/users';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processCreateUsers(_response);
      });
    }

    /**
     * @param body (optional)
     * @param userEmail for login
     * @param externalId for login
     * @return OK
     */
    updateUsers(
      body: ApplicationUserUpdateRequest | undefined,
      userEmail: string,
      externalId: string
    ): Promise<ApplicationUser> {
      let url_ = this.baseUrl + '/users';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'PUT',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processUpdateUsers(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param id Id of "ChargingStation" model from database
     * @return OK
     */
    getChargeStationConfiguration(
      userEmail: string,
      externalId: string,
      id: number
    ): Promise<ChargeController> {
      let url_ = this.baseUrl + '/charge-station/configuration/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationConfiguration(_response);
      });
    }

    /**
     * @param body (optional)
     * @param userEmail for login
     * @param externalId for login
     * @param id Id of "ChargingStation" model from database
     * @return OK
     */
    updateChargeStationConfigurationId(
      body: ChargeController | undefined,
      userEmail: string,
      externalId: string,
      id: number
    ): Promise<ChargeController> {
      let url_ = this.baseUrl + '/charge-station/configuration/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'PUT',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processUpdateChargeStationConfigurationId(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param chargeControllerId
     * @return OK
     */
    getInstallersForChargeStation(
      userEmail: string,
      externalId: string,
      chargeControllerId: number
    ): Promise<ApplicationUser[]> {
      let url_ =
        this.baseUrl + '/charge-station/installers/{chargeControllerId}';
      if (chargeControllerId === undefined || chargeControllerId === null)
        throw new Error("The parameter 'chargeControllerId' must be defined.");
      url_ = url_.replace(
        '{chargeControllerId}',
        encodeURIComponent('' + chargeControllerId)
      );
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetInstallersForChargeStation(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param id Id of "ChargingStation" model from database
     * @return OK
     */
    getChargeStationWhitelist(
      userEmail: string,
      externalId: string,
      id: number
    ): Promise<ChargeController> {
      let url_ = this.baseUrl + '/charge-station/configuration/whitelist/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationWhitelist(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param getAllTransactions get  transactions from last time or not
     * @param externalId for login
     * @param id Id of "ChargingStation" model from database
     * @return OK
     */
    getChargeStationTransaction(
      userEmail: string,
      getAllTransactions: boolean,
      externalId: string,
      id: number
    ): Promise<ChargeController> {
      let url_ =
        this.baseUrl + '/charge-station/configuration/transaction/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          getAllTransactions:
            getAllTransactions !== undefined && getAllTransactions !== null
              ? '' + getAllTransactions
              : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationTransaction(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param id chargePoint id
     * @return OK
     */
    getChargeStationChargePoint(
      userEmail: string,
      externalId: string,
      id: number
    ): Promise<ChargePoint> {
      let url_ = this.baseUrl + '/charge-station/charge-point/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationChargePoint(_response);
      });
    }

    /**
     * @param body (optional)
     * @param id chargePoint id
     * @return OK
     */
    updateChargeStationChargePointId(
      body: ChargePoint | undefined,
      id: number
    ): Promise<ChargePoint> {
      let url_ = this.baseUrl + '/charge-station/charge-point/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processUpdateChargeStationChargePointId(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @return OK
     */
    getChargeStationsOverview(
      userEmail: string,
      externalId: string
    ): Promise<ChargePoint[]> {
      let url_ = this.baseUrl + '/charge-station/overview';
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationsOverview(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param chargeControllerId chageControllerID
     * @return OK
     */
    getChargeStationOcpp(
      userEmail: string,
      externalId: string,
      chargeControllerId: number
    ): Promise<Anonymous> {
      let url_ = this.baseUrl + '/charge-station/ocpp/{chargeControllerId}';
      if (chargeControllerId === undefined || chargeControllerId === null)
        throw new Error("The parameter 'chargeControllerId' must be defined.");
      url_ = url_.replace(
        '{chargeControllerId}',
        encodeURIComponent('' + chargeControllerId)
      );
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationOcpp(_response);
      });
    }

    /**
     * @param body (optional)
     * @param chargeControllerId chageControllerID
     * @return OK
     */
    updateChargeStationOcppConfig(
      body: OcppConfig | undefined,
      chargeControllerId: number
    ): Promise<OcppConfig> {
      let url_ = this.baseUrl + '/charge-station/ocpp/{chargeControllerId}';
      if (chargeControllerId === undefined || chargeControllerId === null)
        throw new Error("The parameter 'chargeControllerId' must be defined.");
      url_ = url_.replace(
        '{chargeControllerId}',
        encodeURIComponent('' + chargeControllerId)
      );
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processUpdateChargeStationOcppConfig(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param chargeControllerId charge controller id
     * @return OK
     */
    getOcppMessages(
      userEmail: string,
      externalId: string,
      chargeControllerId: number
    ): Promise<OcppMessage[]> {
      let url_ =
        this.baseUrl +
        '/charge-station/ocpp/ocpp-messages/{chargeControllerId}';
      if (chargeControllerId === undefined || chargeControllerId === null)
        throw new Error("The parameter 'chargeControllerId' must be defined.");
      url_ = url_.replace(
        '{chargeControllerId}',
        encodeURIComponent('' + chargeControllerId)
      );
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetOcppMessages(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail for login
     * @param externalId for login
     * @param masterId chargeController's serialNumber
     * @param chargeControllerId chargeController's id
     * @return OK
     */
    getChargeStationCommandHistory(
      userEmail: string,
      externalId: string,
      masterId: string,
      chargeControllerId: number
    ): Promise<Anonymous2> {
      let url_ =
        this.baseUrl +
        '/charge-station/command-history/{masterId}/{chargeControllerId}';
      if (masterId === undefined || masterId === null)
        throw new Error("The parameter 'masterId' must be defined.");
      url_ = url_.replace('{masterId}', encodeURIComponent('' + masterId));
      if (chargeControllerId === undefined || chargeControllerId === null)
        throw new Error("The parameter 'chargeControllerId' must be defined.");
      url_ = url_.replace(
        '{chargeControllerId}',
        encodeURIComponent('' + chargeControllerId)
      );
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationCommandHistory(_response);
      });
    }

    /**
     * @param body (optional)
     * @param userEmail for login
     * @param externalId for login
     * @return OK
     */
    postCommand(
      body: Command | undefined,
      userEmail: string,
      externalId: string
    ): Promise<number> {
      let url_ = this.baseUrl + '/command';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'POST',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processPostCommand(_response);
      });
    }

    /**
     * @param inPendingOrProcessingCommands (optional) get commands in pending or processing.
     * @param masterId (optional) chargeControler's serialNumber
     * @return OK
     */
    getCommands(
      inPendingOrProcessingCommands: boolean | undefined,
      masterId: string | undefined
    ): Promise<CommandHistory[]> {
      let url_ = this.baseUrl + '/command?';
      if (inPendingOrProcessingCommands === null)
        throw new Error(
          "The parameter 'inPendingOrProcessingCommands' cannot be null."
        );
      else if (inPendingOrProcessingCommands !== undefined)
        url_ +=
          'inPendingOrProcessingCommands=' +
          encodeURIComponent('' + inPendingOrProcessingCommands) +
          '&';
      if (masterId === null)
        throw new Error("The parameter 'masterId' cannot be null.");
      else if (masterId !== undefined)
        url_ += 'masterId=' + encodeURIComponent('' + masterId) + '&';
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetCommands(_response);
      });
    }

    /**
     * @param body (optional)
     * @return OK
     */
    authenticationBasic(
      body: AuthenticationBasicRequest | undefined
    ): Promise<AuthenticationResponse> {
      let url_ = this.baseUrl + '/authentication/basic';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
        body: content_,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processAuthenticationBasic(_response);
      });
    }

    /**
     * Your GET endpoint
     * @param userEmail (optional) for login
     * @param externalId (optional) for login
     * @param id
     * @return OK
     */
    getChargeStationEmails(
      userEmail: string | undefined,
      externalId: string | undefined,
      id: number
    ): Promise<Email[]> {
      let url_ = this.baseUrl + '/charge-station/emails/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: RequestInit = {
        method: 'GET',
        headers: {
          userEmail:
            userEmail !== undefined && userEmail !== null ? '' + userEmail : '',
          externalId:
            externalId !== undefined && externalId !== null
              ? '' + externalId
              : '',
          Accept: 'application/json',
        },
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
        return this.processGetChargeStationEmails(_response);
      });
    }

    protected processGetUsers(response: Response): Promise<ApplicationUser[]> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ApplicationUser.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ApplicationUser[]>(null as any);
    }

    protected processCreateUsers(response: Response): Promise<ApplicationUser> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApplicationUser.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ApplicationUser>(null as any);
    }

    protected processUpdateUsers(response: Response): Promise<ApplicationUser> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApplicationUser.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ApplicationUser>(null as any);
    }

    protected processGetChargeStationConfiguration(
      response: Response
    ): Promise<ChargeController> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChargeController.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargeController>(null as any);
    }

    protected processUpdateChargeStationConfigurationId(
      response: Response
    ): Promise<ChargeController> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChargeController.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargeController>(null as any);
    }

    protected processGetInstallersForChargeStation(
      response: Response
    ): Promise<ApplicationUser[]> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ApplicationUser.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ApplicationUser[]>(null as any);
    }

    protected processGetChargeStationWhitelist(
      response: Response
    ): Promise<ChargeController> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChargeController.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargeController>(null as any);
    }

    protected processGetChargeStationTransaction(
      response: Response
    ): Promise<ChargeController> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChargeController.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargeController>(null as any);
    }

    protected processGetChargeStationChargePoint(
      response: Response
    ): Promise<ChargePoint> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChargePoint.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargePoint>(null as any);
    }

    protected processUpdateChargeStationChargePointId(
      response: Response
    ): Promise<ChargePoint> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChargePoint.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargePoint>(null as any);
    }

    protected processGetChargeStationsOverview(
      response: Response
    ): Promise<ChargePoint[]> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ChargePoint.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<ChargePoint[]>(null as any);
    }

    protected processGetChargeStationOcpp(
      response: Response
    ): Promise<Anonymous> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Anonymous.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<Anonymous>(null as any);
    }

    protected processUpdateChargeStationOcppConfig(
      response: Response
    ): Promise<OcppConfig> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OcppConfig.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<OcppConfig>(null as any);
    }

    protected processGetOcppMessages(
      response: Response
    ): Promise<OcppMessage[]> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(OcppMessage.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<OcppMessage[]>(null as any);
    }

    protected processGetChargeStationCommandHistory(
      response: Response
    ): Promise<Anonymous2> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Anonymous2.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<Anonymous2>(null as any);
    }

    protected processPostCommand(response: Response): Promise<number> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<number>(null as any);
    }

    protected processGetCommands(
      response: Response
    ): Promise<CommandHistory[]> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CommandHistory.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<CommandHistory[]>(null as any);
    }

    protected processAuthenticationBasic(
      response: Response
    ): Promise<AuthenticationResponse> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticationResponse.fromJS(resultData200);
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<AuthenticationResponse>(null as any);
    }

    protected processGetChargeStationEmails(
      response: Response
    ): Promise<Email[]> {
      const status = response.status;
      let _headers: any = {};
      if (response.headers && response.headers.forEach) {
        response.headers.forEach((v: any, k: any) => (_headers[k] = v));
      }

      if (status === 200) {
        return response.text().then((_responseText) => {
          let result200: any;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(Email.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return result200;
        });
      } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        });
      }
      return Promise.resolve<Email[]>(null as any);
    }
  }

  export class ApplicationUser implements IApplicationUser {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;

    constructor(data?: IApplicationUser) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ApplicationUser {
      data = typeof data === 'object' ? data : {};
      let result = new ApplicationUser();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.firstName = _data['firstName'];
        this.lastName = _data['lastName'];
        this.email = _data['email'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['firstName'] = this.firstName;
      data['lastName'] = this.lastName;
      data['email'] = this.email;
      return data;
    }
  }

  export interface IApplicationUser {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
  }

  export class ApplicationUserUpdateRequest
    implements IApplicationUserUpdateRequest
  {
    id?: number;
    firstName?: string;
    lastName?: string;
    newPassword?: string;
    currentPassword?: string;
    newMasterUid?: string;

    constructor(data?: IApplicationUserUpdateRequest) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ApplicationUserUpdateRequest {
      data = typeof data === 'object' ? data : {};
      let result = new ApplicationUserUpdateRequest();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.firstName = _data['firstName'];
        this.lastName = _data['lastName'];
        this.newPassword = _data['newPassword'];
        this.currentPassword = _data['currentPassword'];
        this.newMasterUid = _data['newMasterUid'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['firstName'] = this.firstName;
      data['lastName'] = this.lastName;
      data['newPassword'] = this.newPassword;
      data['currentPassword'] = this.currentPassword;
      data['newMasterUid'] = this.newMasterUid;
      return data;
    }
  }

  export interface IApplicationUserUpdateRequest {
    id?: number;
    firstName?: string;
    lastName?: string;
    newPassword?: string;
    currentPassword?: string;
    newMasterUid?: string;
  }

  export class ChargeController implements IChargeController {
    id?: number;
    networkConnection?: boolean;
    ocppConnection?: string;
    simActive?: boolean;
    uptimeInSeconds?: number;
    serialNumber?: string;
    address?: string;
    locationData?: string;
    dateInstalled?: Date | undefined;
    lastMaintenance?: Date | undefined;
    systemTime?: Date | undefined;
    networkType?: string;
    eth0DHCP?: boolean;
    eth0IPAddress?: string;
    eth0SubnetMask?: string;
    eth0Gateway?: string;
    modemServiceActive?: boolean;
    modemPreferOverETH0?: boolean;
    modemDefaultRoute?: boolean;
    modemSignalRSSI?: number;
    modemSignalCQI?: number;
    modemReceivedBytes?: number;
    modemTransmittedBytes?: number;
    modemAPN?: string;
    modemSimPin?: string;
    modemUsername?: string;
    modemPassword?: string;
    modemIPAddress?: string;
    modemPrimaryDNSServer?: string;
    modemSecondaryDNSServer?: string;
    modemIMSI?: string;
    modemICCID?: string;
    modemExtendedReport?: string;
    modemConnectionStatus?: string;
    modemProvider?: string;
    modemRegistrationStatus?: string;
    modemRoamingStatus?: string;
    modemSignalQuality?: string;
    modemRadioTechnology?: string;
    modemSimStatus?: string;
    netWorks?: Network[];
    client?: Client;
    installer?: ApplicationUser;
    chargePoints?: ChargePoint[];
    cpuTemperatureCelsius?: number;
    cpuUtilizationPercentage?: number;
    ramAvailableBytes?: number;
    ramTotalBytes?: number;
    ramUsedBytes?: number;
    dataUtilizationPercentage?: number;
    dataTotalBytes?: number;
    logUtilizationPercentage?: number;
    logTotalBytes?: number;
    varVolatileUtilizationPercentage?: number;
    varVolatileTotalBytes?: number;
    systemMonitorVersion?: string;
    systemMonitorStatus?: string;
    controllerAgentVersion?: string;
    controllerAgent_Status?: string;
    ocpp16_Version?: string;
    ocpp16Status?: string;
    modbusClientVersion?: string;
    modbusClientStatus?: string;
    modbusServerVersion?: string;
    modbusServerStatus?: string;
    jupicoreVersion?: string;
    jupicoreStatus?: string;
    loadManagementVersion?: string;
    loadManagementStatus?: string;
    webserverVersion?: string;
    webserverStatus?: string;
    loadManagementActive?: boolean;
    whitelistRFIDs?: Rfid[];
    heartbeat?: Date | undefined;
    ocppConfig?: OcppConfig;
    ocppStatus?: OcppStatus[];
    ocppMessages?: OcppMessage[];
    chargingParkName?: string;
    loadCircuitFuse?: string;
    highLevelMeasuringDeviceControllerId?: string;
    highLevelMeasuringDeviceModbus?: string;
    measuringDeviceType?: string;
    loadStrategy?: string;
    currentI1?: string;
    currentI2?: string;
    currentI3?: string;
    plannedCurrentI1?: string;
    plannedCurrentI2?: string;
    plannedCurrentI3?: string;
    monitoredCps?: string;
    companyName?: string;
    userData?: UserData;
    webAppVersion?: string;
    osReleaseVersion?: string;
    allowTestModeCommands?: boolean;
    useAccessCredentials?: boolean;
    eth0NoGateway?: boolean;
    supervisionMeterCurrentI1?: string;
    supervisionMeterCurrentI2?: string;
    supervisionMeterCurrentI3?: string;
    transactions?: Transaction[];

    constructor(data?: IChargeController) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ChargeController {
      data = typeof data === 'object' ? data : {};
      let result = new ChargeController();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.networkConnection = _data['networkConnection'];
        this.ocppConnection = _data['ocppConnection'];
        this.simActive = _data['SimActive'];
        this.uptimeInSeconds = _data['uptimeInSeconds'];
        this.serialNumber = _data['serialNumber'];
        this.address = _data['address'];
        this.locationData = _data['locationData'];
        this.dateInstalled = _data['dateInstalled']
          ? new Date(_data['dateInstalled'].toString())
          : <any>undefined;
        this.lastMaintenance = _data['lastMaintenance']
          ? new Date(_data['lastMaintenance'].toString())
          : <any>undefined;
        this.systemTime = _data['systemTime']
          ? new Date(_data['systemTime'].toString())
          : <any>undefined;
        this.networkType = _data['networkType'];
        this.eth0DHCP = _data['eth0DHCP'];
        this.eth0IPAddress = _data['eth0IPAddress'];
        this.eth0SubnetMask = _data['eth0SubnetMask'];
        this.eth0Gateway = _data['eth0Gateway'];
        this.modemServiceActive = _data['modemServiceActive'];
        this.modemPreferOverETH0 = _data['modemPreferOverETH0'];
        this.modemDefaultRoute = _data['modemDefaultRoute'];
        this.modemSignalRSSI = _data['modemSignalRSSI'];
        this.modemSignalCQI = _data['modemSignalCQI'];
        this.modemReceivedBytes = _data['modemReceivedBytes'];
        this.modemTransmittedBytes = _data['modemTransmittedBytes'];
        this.modemAPN = _data['modemAPN'];
        this.modemSimPin = _data['modemSimPin'];
        this.modemUsername = _data['modemUsername'];
        this.modemPassword = _data['modemPassword'];
        this.modemIPAddress = _data['modemIPAddress'];
        this.modemPrimaryDNSServer = _data['modemPrimaryDNSServer'];
        this.modemSecondaryDNSServer = _data['modemSecondaryDNSServer'];
        this.modemIMSI = _data['modemIMSI'];
        this.modemICCID = _data['modemICCID'];
        this.modemExtendedReport = _data['modemExtendedReport'];
        this.modemConnectionStatus = _data['modemConnectionStatus'];
        this.modemProvider = _data['modemProvider'];
        this.modemRegistrationStatus = _data['modemRegistrationStatus'];
        this.modemRoamingStatus = _data['modemRoamingStatus'];
        this.modemSignalQuality = _data['modemSignalQuality'];
        this.modemRadioTechnology = _data['modemRadioTechnology'];
        this.modemSimStatus = _data['modemSimStatus'];
        if (Array.isArray(_data['netWorks'])) {
          this.netWorks = [] as any;
          for (let item of _data['netWorks'])
            this.netWorks!.push(Network.fromJS(item));
        }
        this.client = _data['client']
          ? Client.fromJS(_data['client'])
          : <any>undefined;
        this.installer = _data['installer']
          ? ApplicationUser.fromJS(_data['installer'])
          : <any>undefined;
        if (Array.isArray(_data['chargePoints'])) {
          this.chargePoints = [] as any;
          for (let item of _data['chargePoints'])
            this.chargePoints!.push(ChargePoint.fromJS(item));
        }
        this.cpuTemperatureCelsius = _data['cpuTemperatureCelsius'];
        this.cpuUtilizationPercentage = _data['cpuUtilizationPercentage'];
        this.ramAvailableBytes = _data['ramAvailableBytes'];
        this.ramTotalBytes = _data['ramTotalBytes'];
        this.ramUsedBytes = _data['ramUsedBytes'];
        this.dataUtilizationPercentage = _data['dataUtilizationPercentage'];
        this.dataTotalBytes = _data['dataTotalBytes'];
        this.logUtilizationPercentage = _data['logUtilizationPercentage'];
        this.logTotalBytes = _data['logTotalBytes'];
        this.varVolatileUtilizationPercentage =
          _data['varVolatileUtilizationPercentage'];
        this.varVolatileTotalBytes = _data['varVolatileTotalBytes'];
        this.systemMonitorVersion = _data['systemMonitorVersion'];
        this.systemMonitorStatus = _data['systemMonitorStatus'];
        this.controllerAgentVersion = _data['controllerAgentVersion'];
        this.controllerAgent_Status = _data['controllerAgent_Status'];
        this.ocpp16_Version = _data['ocpp16_Version'];
        this.ocpp16Status = _data['ocpp16Status'];
        this.modbusClientVersion = _data['modbusClientVersion'];
        this.modbusClientStatus = _data['modbusClientStatus'];
        this.modbusServerVersion = _data['modbusServerVersion'];
        this.modbusServerStatus = _data['modbusServerStatus'];
        this.jupicoreVersion = _data['jupicoreVersion'];
        this.jupicoreStatus = _data['jupicoreStatus'];
        this.loadManagementVersion = _data['loadManagementVersion'];
        this.loadManagementStatus = _data['loadManagementStatus'];
        this.webserverVersion = _data['webserverVersion'];
        this.webserverStatus = _data['webserverStatus'];
        this.loadManagementActive = _data['loadManagementActive'];
        if (Array.isArray(_data['whitelistRFIDs'])) {
          this.whitelistRFIDs = [] as any;
          for (let item of _data['whitelistRFIDs'])
            this.whitelistRFIDs!.push(Rfid.fromJS(item));
        }
        this.heartbeat = _data['heartbeat']
          ? new Date(_data['heartbeat'].toString())
          : <any>undefined;
        this.ocppConfig = _data['ocppConfig']
          ? OcppConfig.fromJS(_data['ocppConfig'])
          : <any>undefined;
        if (Array.isArray(_data['ocppStatus'])) {
          this.ocppStatus = [] as any;
          for (let item of _data['ocppStatus'])
            this.ocppStatus!.push(OcppStatus.fromJS(item));
        }
        if (Array.isArray(_data['ocppMessages'])) {
          this.ocppMessages = [] as any;
          for (let item of _data['ocppMessages'])
            this.ocppMessages!.push(OcppMessage.fromJS(item));
        }
        this.chargingParkName = _data['chargingParkName'];
        this.loadCircuitFuse = _data['loadCircuitFuse'];
        this.highLevelMeasuringDeviceControllerId =
          _data['highLevelMeasuringDeviceControllerId'];
        this.highLevelMeasuringDeviceModbus =
          _data['highLevelMeasuringDeviceModbus'];
        this.measuringDeviceType = _data['measuringDeviceType'];
        this.loadStrategy = _data['loadStrategy'];
        this.currentI1 = _data['currentI1'];
        this.currentI2 = _data['currentI2'];
        this.currentI3 = _data['currentI3'];
        this.plannedCurrentI1 = _data['plannedCurrentI1'];
        this.plannedCurrentI2 = _data['plannedCurrentI2'];
        this.plannedCurrentI3 = _data['plannedCurrentI3'];
        this.monitoredCps = _data['monitoredCps'];
        this.companyName = _data['companyName'];
        this.userData = _data['userData']
          ? UserData.fromJS(_data['userData'])
          : <any>undefined;
        this.webAppVersion = _data['webAppVersion'];
        this.osReleaseVersion = _data['osReleaseVersion'];
        this.allowTestModeCommands = _data['allowTestModeCommands'];
        this.useAccessCredentials = _data['useAccessCredentials'];
        this.eth0NoGateway = _data['eth0NoGateway'];
        this.supervisionMeterCurrentI1 = _data['supervisionMeterCurrentI1'];
        this.supervisionMeterCurrentI2 = _data['supervisionMeterCurrentI2'];
        this.supervisionMeterCurrentI3 = _data['supervisionMeterCurrentI3'];
        if (Array.isArray(_data['transactions'])) {
          this.transactions = [] as any;
          for (let item of _data['transactions'])
            this.transactions!.push(Transaction.fromJS(item));
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['networkConnection'] = this.networkConnection;
      data['ocppConnection'] = this.ocppConnection;
      data['SimActive'] = this.simActive;
      data['uptimeInSeconds'] = this.uptimeInSeconds;
      data['serialNumber'] = this.serialNumber;
      data['address'] = this.address;
      data['locationData'] = this.locationData;
      data['dateInstalled'] = this.dateInstalled
        ? this.dateInstalled.toISOString()
        : <any>undefined;
      data['lastMaintenance'] = this.lastMaintenance
        ? this.lastMaintenance.toISOString()
        : <any>undefined;
      data['systemTime'] = this.systemTime
        ? this.systemTime.toISOString()
        : <any>undefined;
      data['networkType'] = this.networkType;
      data['eth0DHCP'] = this.eth0DHCP;
      data['eth0IPAddress'] = this.eth0IPAddress;
      data['eth0SubnetMask'] = this.eth0SubnetMask;
      data['eth0Gateway'] = this.eth0Gateway;
      data['modemServiceActive'] = this.modemServiceActive;
      data['modemPreferOverETH0'] = this.modemPreferOverETH0;
      data['modemDefaultRoute'] = this.modemDefaultRoute;
      data['modemSignalRSSI'] = this.modemSignalRSSI;
      data['modemSignalCQI'] = this.modemSignalCQI;
      data['modemReceivedBytes'] = this.modemReceivedBytes;
      data['modemTransmittedBytes'] = this.modemTransmittedBytes;
      data['modemAPN'] = this.modemAPN;
      data['modemSimPin'] = this.modemSimPin;
      data['modemUsername'] = this.modemUsername;
      data['modemPassword'] = this.modemPassword;
      data['modemIPAddress'] = this.modemIPAddress;
      data['modemPrimaryDNSServer'] = this.modemPrimaryDNSServer;
      data['modemSecondaryDNSServer'] = this.modemSecondaryDNSServer;
      data['modemIMSI'] = this.modemIMSI;
      data['modemICCID'] = this.modemICCID;
      data['modemExtendedReport'] = this.modemExtendedReport;
      data['modemConnectionStatus'] = this.modemConnectionStatus;
      data['modemProvider'] = this.modemProvider;
      data['modemRegistrationStatus'] = this.modemRegistrationStatus;
      data['modemRoamingStatus'] = this.modemRoamingStatus;
      data['modemSignalQuality'] = this.modemSignalQuality;
      data['modemRadioTechnology'] = this.modemRadioTechnology;
      data['modemSimStatus'] = this.modemSimStatus;
      if (Array.isArray(this.netWorks)) {
        data['netWorks'] = [];
        for (let item of this.netWorks) data['netWorks'].push(item.toJSON());
      }
      data['client'] = this.client ? this.client.toJSON() : <any>undefined;
      data['installer'] = this.installer
        ? this.installer.toJSON()
        : <any>undefined;
      if (Array.isArray(this.chargePoints)) {
        data['chargePoints'] = [];
        for (let item of this.chargePoints)
          data['chargePoints'].push(item.toJSON());
      }
      data['cpuTemperatureCelsius'] = this.cpuTemperatureCelsius;
      data['cpuUtilizationPercentage'] = this.cpuUtilizationPercentage;
      data['ramAvailableBytes'] = this.ramAvailableBytes;
      data['ramTotalBytes'] = this.ramTotalBytes;
      data['ramUsedBytes'] = this.ramUsedBytes;
      data['dataUtilizationPercentage'] = this.dataUtilizationPercentage;
      data['dataTotalBytes'] = this.dataTotalBytes;
      data['logUtilizationPercentage'] = this.logUtilizationPercentage;
      data['logTotalBytes'] = this.logTotalBytes;
      data['varVolatileUtilizationPercentage'] =
        this.varVolatileUtilizationPercentage;
      data['varVolatileTotalBytes'] = this.varVolatileTotalBytes;
      data['systemMonitorVersion'] = this.systemMonitorVersion;
      data['systemMonitorStatus'] = this.systemMonitorStatus;
      data['controllerAgentVersion'] = this.controllerAgentVersion;
      data['controllerAgent_Status'] = this.controllerAgent_Status;
      data['ocpp16_Version'] = this.ocpp16_Version;
      data['ocpp16Status'] = this.ocpp16Status;
      data['modbusClientVersion'] = this.modbusClientVersion;
      data['modbusClientStatus'] = this.modbusClientStatus;
      data['modbusServerVersion'] = this.modbusServerVersion;
      data['modbusServerStatus'] = this.modbusServerStatus;
      data['jupicoreVersion'] = this.jupicoreVersion;
      data['jupicoreStatus'] = this.jupicoreStatus;
      data['loadManagementVersion'] = this.loadManagementVersion;
      data['loadManagementStatus'] = this.loadManagementStatus;
      data['webserverVersion'] = this.webserverVersion;
      data['webserverStatus'] = this.webserverStatus;
      data['loadManagementActive'] = this.loadManagementActive;
      if (Array.isArray(this.whitelistRFIDs)) {
        data['whitelistRFIDs'] = [];
        for (let item of this.whitelistRFIDs)
          data['whitelistRFIDs'].push(item.toJSON());
      }
      data['heartbeat'] = this.heartbeat
        ? this.heartbeat.toISOString()
        : <any>undefined;
      data['ocppConfig'] = this.ocppConfig
        ? this.ocppConfig.toJSON()
        : <any>undefined;
      if (Array.isArray(this.ocppStatus)) {
        data['ocppStatus'] = [];
        for (let item of this.ocppStatus)
          data['ocppStatus'].push(item.toJSON());
      }
      if (Array.isArray(this.ocppMessages)) {
        data['ocppMessages'] = [];
        for (let item of this.ocppMessages)
          data['ocppMessages'].push(item.toJSON());
      }
      data['chargingParkName'] = this.chargingParkName;
      data['loadCircuitFuse'] = this.loadCircuitFuse;
      data['highLevelMeasuringDeviceControllerId'] =
        this.highLevelMeasuringDeviceControllerId;
      data['highLevelMeasuringDeviceModbus'] =
        this.highLevelMeasuringDeviceModbus;
      data['measuringDeviceType'] = this.measuringDeviceType;
      data['loadStrategy'] = this.loadStrategy;
      data['currentI1'] = this.currentI1;
      data['currentI2'] = this.currentI2;
      data['currentI3'] = this.currentI3;
      data['plannedCurrentI1'] = this.plannedCurrentI1;
      data['plannedCurrentI2'] = this.plannedCurrentI2;
      data['plannedCurrentI3'] = this.plannedCurrentI3;
      data['monitoredCps'] = this.monitoredCps;
      data['companyName'] = this.companyName;
      data['userData'] = this.userData
        ? this.userData.toJSON()
        : <any>undefined;
      data['webAppVersion'] = this.webAppVersion;
      data['osReleaseVersion'] = this.osReleaseVersion;
      data['allowTestModeCommands'] = this.allowTestModeCommands;
      data['useAccessCredentials'] = this.useAccessCredentials;
      data['eth0NoGateway'] = this.eth0NoGateway;
      data['supervisionMeterCurrentI1'] = this.supervisionMeterCurrentI1;
      data['supervisionMeterCurrentI2'] = this.supervisionMeterCurrentI2;
      data['supervisionMeterCurrentI3'] = this.supervisionMeterCurrentI3;
      if (Array.isArray(this.transactions)) {
        data['transactions'] = [];
        for (let item of this.transactions)
          data['transactions'].push(item.toJSON());
      }
      return data;
    }
  }

  export interface IChargeController {
    id?: number;
    networkConnection?: boolean;
    ocppConnection?: string;
    simActive?: boolean;
    uptimeInSeconds?: number;
    serialNumber?: string;
    address?: string;
    locationData?: string;
    dateInstalled?: Date | undefined;
    lastMaintenance?: Date | undefined;
    systemTime?: Date | undefined;
    networkType?: string;
    eth0DHCP?: boolean;
    eth0IPAddress?: string;
    eth0SubnetMask?: string;
    eth0Gateway?: string;
    modemServiceActive?: boolean;
    modemPreferOverETH0?: boolean;
    modemDefaultRoute?: boolean;
    modemSignalRSSI?: number;
    modemSignalCQI?: number;
    modemReceivedBytes?: number;
    modemTransmittedBytes?: number;
    modemAPN?: string;
    modemSimPin?: string;
    modemUsername?: string;
    modemPassword?: string;
    modemIPAddress?: string;
    modemPrimaryDNSServer?: string;
    modemSecondaryDNSServer?: string;
    modemIMSI?: string;
    modemICCID?: string;
    modemExtendedReport?: string;
    modemConnectionStatus?: string;
    modemProvider?: string;
    modemRegistrationStatus?: string;
    modemRoamingStatus?: string;
    modemSignalQuality?: string;
    modemRadioTechnology?: string;
    modemSimStatus?: string;
    netWorks?: Network[];
    client?: Client;
    installer?: ApplicationUser;
    chargePoints?: ChargePoint[];
    cpuTemperatureCelsius?: number;
    cpuUtilizationPercentage?: number;
    ramAvailableBytes?: number;
    ramTotalBytes?: number;
    ramUsedBytes?: number;
    dataUtilizationPercentage?: number;
    dataTotalBytes?: number;
    logUtilizationPercentage?: number;
    logTotalBytes?: number;
    varVolatileUtilizationPercentage?: number;
    varVolatileTotalBytes?: number;
    systemMonitorVersion?: string;
    systemMonitorStatus?: string;
    controllerAgentVersion?: string;
    controllerAgent_Status?: string;
    ocpp16_Version?: string;
    ocpp16Status?: string;
    modbusClientVersion?: string;
    modbusClientStatus?: string;
    modbusServerVersion?: string;
    modbusServerStatus?: string;
    jupicoreVersion?: string;
    jupicoreStatus?: string;
    loadManagementVersion?: string;
    loadManagementStatus?: string;
    webserverVersion?: string;
    webserverStatus?: string;
    loadManagementActive?: boolean;
    whitelistRFIDs?: Rfid[];
    heartbeat?: Date | undefined;
    ocppConfig?: OcppConfig;
    ocppStatus?: OcppStatus[];
    ocppMessages?: OcppMessage[];
    chargingParkName?: string;
    loadCircuitFuse?: string;
    highLevelMeasuringDeviceControllerId?: string;
    highLevelMeasuringDeviceModbus?: string;
    measuringDeviceType?: string;
    loadStrategy?: string;
    currentI1?: string;
    currentI2?: string;
    currentI3?: string;
    plannedCurrentI1?: string;
    plannedCurrentI2?: string;
    plannedCurrentI3?: string;
    monitoredCps?: string;
    companyName?: string;
    userData?: UserData;
    webAppVersion?: string;
    osReleaseVersion?: string;
    allowTestModeCommands?: boolean;
    useAccessCredentials?: boolean;
    eth0NoGateway?: boolean;
    supervisionMeterCurrentI1?: string;
    supervisionMeterCurrentI2?: string;
    supervisionMeterCurrentI3?: string;
    transactions?: Transaction[];
  }

  export class ChargePoint implements IChargePoint {
    id?: number;
    enabled?: boolean;
    chargingTimeInSeconds?: number;
    chargeCurrentMinimumInAmpers?: number;
    chargeCurrentMaximumInAmpers?: number;
    fallbackCurrentInAmpers?: number;
    fallbackTimeInSeconds?: number;
    rfidTimeoutInSeconds?: number;
    ocppConnectorId?: number;
    chargePointUid?: string;
    chargeControllerUid?: string;
    chargingRate?: number;
    name?: string;
    softwareVersion?: string;
    location?: string;
    state?: string;
    energyType?: string;
    phaseRotation?: string;
    releaseChargingMode?: string;
    rfidReader?: string;
    rfidReaderType?: string;
    highLevelCommunication?: string;
    chargeController?: ChargeController;
    slaveSerialNumber?: string;
    serialNumber?: string;
    externalRelease?: boolean;
    names?: string[];
    releaseChargingModes?: string[];
    states?: string[];

    constructor(data?: IChargePoint) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ChargePoint {
      data = typeof data === 'object' ? data : {};
      let result = new ChargePoint();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.enabled = _data['enabled'];
        this.chargingTimeInSeconds = _data['chargingTimeInSeconds'];
        this.chargeCurrentMinimumInAmpers =
          _data['chargeCurrentMinimumInAmpers'];
        this.chargeCurrentMaximumInAmpers =
          _data['chargeCurrentMaximumInAmpers'];
        this.fallbackCurrentInAmpers = _data['fallbackCurrentInAmpers'];
        this.fallbackTimeInSeconds = _data['fallbackTimeInSeconds'];
        this.rfidTimeoutInSeconds = _data['rfidTimeoutInSeconds'];
        this.ocppConnectorId = _data['ocppConnectorId'];
        this.chargePointUid = _data['chargePointUid'];
        this.chargeControllerUid = _data['chargeControllerUid'];
        this.chargingRate = _data['chargingRate'];
        this.name = _data['name'];
        this.softwareVersion = _data['softwareVersion'];
        this.location = _data['location'];
        this.state = _data['state'];
        this.energyType = _data['energyType'];
        this.phaseRotation = _data['phaseRotation'];
        this.releaseChargingMode = _data['releaseChargingMode'];
        this.rfidReader = _data['rfidReader'];
        this.rfidReaderType = _data['rfidReaderType'];
        this.highLevelCommunication = _data['highLevelCommunication'];
        this.chargeController = _data['chargeController']
          ? ChargeController.fromJS(_data['chargeController'])
          : <any>undefined;
        this.slaveSerialNumber = _data['slaveSerialNumber'];
        this.serialNumber = _data['serialNumber'];
        this.externalRelease = _data['externalRelease'];
        if (Array.isArray(_data['names'])) {
          this.names = [] as any;
          for (let item of _data['names']) this.names!.push(item);
        }
        if (Array.isArray(_data['releaseChargingModes'])) {
          this.releaseChargingModes = [] as any;
          for (let item of _data['releaseChargingModes'])
            this.releaseChargingModes!.push(item);
        }
        if (Array.isArray(_data['states'])) {
          this.states = [] as any;
          for (let item of _data['states']) this.states!.push(item);
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['enabled'] = this.enabled;
      data['chargingTimeInSeconds'] = this.chargingTimeInSeconds;
      data['chargeCurrentMinimumInAmpers'] = this.chargeCurrentMinimumInAmpers;
      data['chargeCurrentMaximumInAmpers'] = this.chargeCurrentMaximumInAmpers;
      data['fallbackCurrentInAmpers'] = this.fallbackCurrentInAmpers;
      data['fallbackTimeInSeconds'] = this.fallbackTimeInSeconds;
      data['rfidTimeoutInSeconds'] = this.rfidTimeoutInSeconds;
      data['ocppConnectorId'] = this.ocppConnectorId;
      data['chargePointUid'] = this.chargePointUid;
      data['chargeControllerUid'] = this.chargeControllerUid;
      data['chargingRate'] = this.chargingRate;
      data['name'] = this.name;
      data['softwareVersion'] = this.softwareVersion;
      data['location'] = this.location;
      data['state'] = this.state;
      data['energyType'] = this.energyType;
      data['phaseRotation'] = this.phaseRotation;
      data['releaseChargingMode'] = this.releaseChargingMode;
      data['rfidReader'] = this.rfidReader;
      data['rfidReaderType'] = this.rfidReaderType;
      data['highLevelCommunication'] = this.highLevelCommunication;
      data['chargeController'] = this.chargeController
        ? this.chargeController.toJSON()
        : <any>undefined;
      data['slaveSerialNumber'] = this.slaveSerialNumber;
      data['serialNumber'] = this.serialNumber;
      data['externalRelease'] = this.externalRelease;
      if (Array.isArray(this.names)) {
        data['names'] = [];
        for (let item of this.names) data['names'].push(item);
      }
      if (Array.isArray(this.releaseChargingModes)) {
        data['releaseChargingModes'] = [];
        for (let item of this.releaseChargingModes)
          data['releaseChargingModes'].push(item);
      }
      if (Array.isArray(this.states)) {
        data['states'] = [];
        for (let item of this.states) data['states'].push(item);
      }
      return data;
    }
  }

  export interface IChargePoint {
    id?: number;
    enabled?: boolean;
    chargingTimeInSeconds?: number;
    chargeCurrentMinimumInAmpers?: number;
    chargeCurrentMaximumInAmpers?: number;
    fallbackCurrentInAmpers?: number;
    fallbackTimeInSeconds?: number;
    rfidTimeoutInSeconds?: number;
    ocppConnectorId?: number;
    chargePointUid?: string;
    chargeControllerUid?: string;
    chargingRate?: number;
    name?: string;
    softwareVersion?: string;
    location?: string;
    state?: string;
    energyType?: string;
    phaseRotation?: string;
    releaseChargingMode?: string;
    rfidReader?: string;
    rfidReaderType?: string;
    highLevelCommunication?: string;
    chargeController?: ChargeController;
    slaveSerialNumber?: string;
    serialNumber?: string;
    externalRelease?: boolean;
    names?: string[];
    releaseChargingModes?: string[];
    states?: string[];
  }

  export class Network implements INetwork {
    id?: number;
    chargingStationId?: number;
    name?: string;
    ipV4Address?: string;
    ipV6Address?: string;
    macAddress?: string;
    receivedBytes?: number;
    transmittedBytes?: number;

    constructor(data?: INetwork) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Network {
      data = typeof data === 'object' ? data : {};
      let result = new Network();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.chargingStationId = _data['chargingStationId'];
        this.name = _data['name'];
        this.ipV4Address = _data['ipV4Address'];
        this.ipV6Address = _data['ipV6Address'];
        this.macAddress = _data['macAddress'];
        this.receivedBytes = _data['receivedBytes'];
        this.transmittedBytes = _data['transmittedBytes'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['chargingStationId'] = this.chargingStationId;
      data['name'] = this.name;
      data['ipV4Address'] = this.ipV4Address;
      data['ipV6Address'] = this.ipV6Address;
      data['macAddress'] = this.macAddress;
      data['receivedBytes'] = this.receivedBytes;
      data['transmittedBytes'] = this.transmittedBytes;
      return data;
    }
  }

  export interface INetwork {
    id?: number;
    chargingStationId?: number;
    name?: string;
    ipV4Address?: string;
    ipV6Address?: string;
    macAddress?: string;
    receivedBytes?: number;
    transmittedBytes?: number;
  }

  export class Client implements IClient {
    id?: number;
    name?: string;
    location?: string;
    phone?: string;
    email?: string;

    constructor(data?: IClient) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Client {
      data = typeof data === 'object' ? data : {};
      let result = new Client();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.name = _data['name'];
        this.location = _data['location'];
        this.phone = _data['phone'];
        this.email = _data['email'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['name'] = this.name;
      data['location'] = this.location;
      data['phone'] = this.phone;
      data['email'] = this.email;
      return data;
    }
  }

  export interface IClient {
    id?: number;
    name?: string;
    location?: string;
    phone?: string;
    email?: string;
  }

  export class Rfid implements IRfid {
    id?: number;
    allowCharging?: boolean;
    evConsumptionRateKWhPer100KM?: number;
    name?: string;
    serialNumber?: string;
    expiryDate?: Date | undefined;
    type?: string;

    constructor(data?: IRfid) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Rfid {
      data = typeof data === 'object' ? data : {};
      let result = new Rfid();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.allowCharging = _data['allowCharging'];
        this.evConsumptionRateKWhPer100KM =
          _data['evConsumptionRateKWhPer100KM'];
        this.name = _data['name'];
        this.serialNumber = _data['serialNumber'];
        this.expiryDate = _data['expiryDate']
          ? new Date(_data['expiryDate'].toString())
          : <any>undefined;
        this.type = _data['type'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['allowCharging'] = this.allowCharging;
      data['evConsumptionRateKWhPer100KM'] = this.evConsumptionRateKWhPer100KM;
      data['name'] = this.name;
      data['serialNumber'] = this.serialNumber;
      data['expiryDate'] = this.expiryDate
        ? this.expiryDate.toISOString()
        : <any>undefined;
      data['type'] = this.type;
      return data;
    }
  }

  export interface IRfid {
    id?: number;
    allowCharging?: boolean;
    evConsumptionRateKWhPer100KM?: number;
    name?: string;
    serialNumber?: string;
    expiryDate?: Date | undefined;
    type?: string;
  }

  export class OcppStatus implements IOcppStatus {
    id?: number;
    status?: string;
    occpStatusSentDate?: Date | undefined;
    occpStatus?: string;
    operative?: boolean;
    chargeController?: ChargeController;
    device_uid?: string;

    constructor(data?: IOcppStatus) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): OcppStatus {
      data = typeof data === 'object' ? data : {};
      let result = new OcppStatus();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.status = _data['status'];
        this.occpStatusSentDate = _data['occpStatusSentDate']
          ? new Date(_data['occpStatusSentDate'].toString())
          : <any>undefined;
        this.occpStatus = _data['occpStatus'];
        this.operative = _data['operative'];
        this.chargeController = _data['chargeController']
          ? ChargeController.fromJS(_data['chargeController'])
          : <any>undefined;
        this.device_uid = _data['device_uid'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['status'] = this.status;
      data['occpStatusSentDate'] = this.occpStatusSentDate
        ? this.occpStatusSentDate.toISOString()
        : <any>undefined;
      data['occpStatus'] = this.occpStatus;
      data['operative'] = this.operative;
      data['chargeController'] = this.chargeController
        ? this.chargeController.toJSON()
        : <any>undefined;
      data['device_uid'] = this.device_uid;
      return data;
    }
  }

  export interface IOcppStatus {
    id?: number;
    status?: string;
    occpStatusSentDate?: Date | undefined;
    occpStatus?: string;
    operative?: boolean;
    chargeController?: ChargeController;
    device_uid?: string;
  }

  export class OcppMessage implements IOcppMessage {
    id?: number;
    ocpp?: ChargeController;
    timestamp?: Date | undefined;
    type?: number;
    action?: string;
    messageData?: string;
    fromLastHeartbeat?: boolean;

    constructor(data?: IOcppMessage) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): OcppMessage {
      data = typeof data === 'object' ? data : {};
      let result = new OcppMessage();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.ocpp = _data['ocpp']
          ? ChargeController.fromJS(_data['ocpp'])
          : <any>undefined;
        this.timestamp = _data['timestamp']
          ? new Date(_data['timestamp'].toString())
          : <any>undefined;
        this.type = _data['type'];
        this.action = _data['action'];
        this.messageData = _data['messageData'];
        this.fromLastHeartbeat = _data['fromLastHeartbeat'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['ocpp'] = this.ocpp ? this.ocpp.toJSON() : <any>undefined;
      data['timestamp'] = this.timestamp
        ? this.timestamp.toISOString()
        : <any>undefined;
      data['type'] = this.type;
      data['action'] = this.action;
      data['messageData'] = this.messageData;
      data['fromLastHeartbeat'] = this.fromLastHeartbeat;
      return data;
    }
  }

  export interface IOcppMessage {
    id?: number;
    ocpp?: ChargeController;
    timestamp?: Date | undefined;
    type?: number;
    action?: string;
    messageData?: string;
    fromLastHeartbeat?: boolean;
  }

  export class OcppConfig implements IOcppConfig {
    id?: number;
    chargeController?: ChargeController;
    ocppProtocolVersion?: string;
    networkInterface?: string;
    backendURL?: string;
    serviceRFID?: string;
    freeModeRFID?: string;
    chargeStationModel?: string;
    chargeStationVendor?: string;
    chargeStationSerialNumber?: string;
    chargeControllerId?: number;
    serviceRestart?: boolean;
    meterType?: string;
    meterSerialNumber?: string;
    imsi?: string;
    iccid?: string;
    chargeBoxSerialNumber?: string;
    chargeBoxID?: string;
    freeMode?: boolean;

    constructor(data?: IOcppConfig) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): OcppConfig {
      data = typeof data === 'object' ? data : {};
      let result = new OcppConfig();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.chargeController = _data['chargeController']
          ? ChargeController.fromJS(_data['chargeController'])
          : <any>undefined;
        this.ocppProtocolVersion = _data['ocppProtocolVersion'];
        this.networkInterface = _data['networkInterface'];
        this.backendURL = _data['backendURL'];
        this.serviceRFID = _data['serviceRFID'];
        this.freeModeRFID = _data['freeModeRFID'];
        this.chargeStationModel = _data['chargeStationModel'];
        this.chargeStationVendor = _data['chargeStationVendor'];
        this.chargeStationSerialNumber = _data['chargeStationSerialNumber'];
        this.chargeControllerId = _data['chargeControllerId'];
        this.serviceRestart = _data['serviceRestart'];
        this.meterType = _data['meterType'];
        this.meterSerialNumber = _data['meterSerialNumber'];
        this.imsi = _data['imsi'];
        this.iccid = _data['iccid'];
        this.chargeBoxSerialNumber = _data['chargeBoxSerialNumber'];
        this.chargeBoxID = _data['chargeBoxID'];
        this.freeMode = _data['freeMode'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['chargeController'] = this.chargeController
        ? this.chargeController.toJSON()
        : <any>undefined;
      data['ocppProtocolVersion'] = this.ocppProtocolVersion;
      data['networkInterface'] = this.networkInterface;
      data['backendURL'] = this.backendURL;
      data['serviceRFID'] = this.serviceRFID;
      data['freeModeRFID'] = this.freeModeRFID;
      data['chargeStationModel'] = this.chargeStationModel;
      data['chargeStationVendor'] = this.chargeStationVendor;
      data['chargeStationSerialNumber'] = this.chargeStationSerialNumber;
      data['chargeControllerId'] = this.chargeControllerId;
      data['serviceRestart'] = this.serviceRestart;
      data['meterType'] = this.meterType;
      data['meterSerialNumber'] = this.meterSerialNumber;
      data['imsi'] = this.imsi;
      data['iccid'] = this.iccid;
      data['chargeBoxSerialNumber'] = this.chargeBoxSerialNumber;
      data['chargeBoxID'] = this.chargeBoxID;
      data['freeMode'] = this.freeMode;
      return data;
    }
  }

  export interface IOcppConfig {
    id?: number;
    chargeController?: ChargeController;
    ocppProtocolVersion?: string;
    networkInterface?: string;
    backendURL?: string;
    serviceRFID?: string;
    freeModeRFID?: string;
    chargeStationModel?: string;
    chargeStationVendor?: string;
    chargeStationSerialNumber?: string;
    chargeControllerId?: number;
    serviceRestart?: boolean;
    meterType?: string;
    meterSerialNumber?: string;
    imsi?: string;
    iccid?: string;
    chargeBoxSerialNumber?: string;
    chargeBoxID?: string;
    freeMode?: boolean;
  }

  export class UserData implements IUserData {
    id?: number;
    jsonData?: string;
    created?: Date | undefined;

    constructor(data?: IUserData) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): UserData {
      data = typeof data === 'object' ? data : {};
      let result = new UserData();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.jsonData = _data['jsonData'];
        this.created = _data['created']
          ? new Date(_data['created'].toString())
          : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['jsonData'] = this.jsonData;
      data['created'] = this.created
        ? this.created.toISOString()
        : <any>undefined;
      return data;
    }
  }

  export interface IUserData {
    id?: number;
    jsonData?: string;
    created?: Date | undefined;
  }

  export class Command implements ICommand {
    type?: CommandType;
    payload?: string;
    chargeControllerId?: number | undefined;
    chargePointId?: number | undefined;
    additionalValue?: any;

    constructor(data?: ICommand) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Command {
      data = typeof data === 'object' ? data : {};
      let result = new Command();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.type = _data['type'];
        this.payload = _data['payload'];
        this.chargeControllerId = _data['chargeControllerId'];
        this.chargePointId = _data['chargePointId'];
        this.additionalValue = _data['additionalValue'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['type'] = this.type;
      data['payload'] = this.payload;
      data['chargeControllerId'] = this.chargeControllerId;
      data['chargePointId'] = this.chargePointId;
      data['additionalValue'] = this.additionalValue;
      return data;
    }
  }

  export interface ICommand {
    type?: CommandType;
    payload?: string;
    chargeControllerId?: number | undefined;
    chargePointId?: number | undefined;
    additionalValue?: any;
  }

  export class CommandHistory implements ICommandHistory {
    commandId?: number;
    chargePointUid?: string;
    chargeControllerUid?: string;
    status?: string;
    createdDate?: Date | undefined;
    processedDate?: Date | undefined;
    masterUrl?: string;
    method?: string;
    payload?: string;
    name?: string;
    errorMessage?: string;
    commandType?: string;
    rfidSerialNumber?: string;
    port?: number;
    tokenRequired?: boolean;

    constructor(data?: ICommandHistory) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): CommandHistory {
      data = typeof data === 'object' ? data : {};
      let result = new CommandHistory();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.commandId = _data['commandId'];
        this.chargePointUid = _data['chargePointUid'];
        this.chargeControllerUid = _data['chargeControllerUid'];
        this.status = _data['status'];
        this.createdDate = _data['createdDate']
          ? new Date(_data['createdDate'].toString())
          : <any>undefined;
        this.processedDate = _data['processedDate']
          ? new Date(_data['processedDate'].toString())
          : <any>undefined;
        this.masterUrl = _data['masterUrl'];
        this.method = _data['method'];
        this.payload = _data['payload'];
        this.name = _data['name'];
        this.errorMessage = _data['errorMessage'];
        this.commandType = _data['commandType'];
        this.rfidSerialNumber = _data['rfidSerialNumber'];
        this.port = _data['port'];
        this.tokenRequired = _data['tokenRequired'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['commandId'] = this.commandId;
      data['chargePointUid'] = this.chargePointUid;
      data['chargeControllerUid'] = this.chargeControllerUid;
      data['status'] = this.status;
      data['createdDate'] = this.createdDate
        ? this.createdDate.toISOString()
        : <any>undefined;
      data['processedDate'] = this.processedDate
        ? this.processedDate.toISOString()
        : <any>undefined;
      data['masterUrl'] = this.masterUrl;
      data['method'] = this.method;
      data['payload'] = this.payload;
      data['name'] = this.name;
      data['errorMessage'] = this.errorMessage;
      data['commandType'] = this.commandType;
      data['rfidSerialNumber'] = this.rfidSerialNumber;
      data['port'] = this.port;
      data['tokenRequired'] = this.tokenRequired;
      return data;
    }
  }

  export interface ICommandHistory {
    commandId?: number;
    chargePointUid?: string;
    chargeControllerUid?: string;
    status?: string;
    createdDate?: Date | undefined;
    processedDate?: Date | undefined;
    masterUrl?: string;
    method?: string;
    payload?: string;
    name?: string;
    errorMessage?: string;
    commandType?: string;
    rfidSerialNumber?: string;
    port?: number;
    tokenRequired?: boolean;
  }

  export class AuthenticationResponse implements IAuthenticationResponse {
    success?: boolean;
    token?: string;

    constructor(data?: IAuthenticationResponse) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): AuthenticationResponse {
      data = typeof data === 'object' ? data : {};
      let result = new AuthenticationResponse();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.success = _data['success'];
        this.token = _data['token'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['success'] = this.success;
      data['token'] = this.token;
      return data;
    }
  }

  export interface IAuthenticationResponse {
    success?: boolean;
    token?: string;
  }

  export class AuthenticationBasicRequest
    implements IAuthenticationBasicRequest
  {
    email?: string;
    externalId?: string;
    role?: string;
    nickname?: string;

    constructor(data?: IAuthenticationBasicRequest) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): AuthenticationBasicRequest {
      data = typeof data === 'object' ? data : {};
      let result = new AuthenticationBasicRequest();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.email = _data['email'];
        this.externalId = _data['externalId'];
        this.role = _data['role'];
        this.nickname = _data['nickname'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['email'] = this.email;
      data['externalId'] = this.externalId;
      data['role'] = this.role;
      data['nickname'] = this.nickname;
      return data;
    }
  }

  export interface IAuthenticationBasicRequest {
    email?: string;
    externalId?: string;
    role?: string;
    nickname?: string;
  }

  export class Transaction implements ITransaction {
    chargeControllerId?: number;
    chargePointId?: number;
    chargePointName?: string;
    rfidTag?: string;
    rfidName?: string;
    startDay?: string;
    startMonth?: string;
    startYear?: string;
    startDayOfWeek?: string;
    startTime?: string;
    endTime?: string;
    durationDays?: string;
    connectedTimeSec?: number;
    chargeTimeSec?: number;
    averagePower?: number;
    chargedEnergy?: number;
    chargedDistance?: number;
    id?: number;
    transactionId?: number;
    createdDate?: Date | undefined;

    constructor(data?: ITransaction) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Transaction {
      data = typeof data === 'object' ? data : {};
      let result = new Transaction();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.chargeControllerId = _data['chargeControllerId'];
        this.chargePointId = _data['chargePointId'];
        this.chargePointName = _data['chargePointName'];
        this.rfidTag = _data['rfidTag'];
        this.rfidName = _data['rfidName'];
        this.startDay = _data['startDay'];
        this.startMonth = _data['startMonth'];
        this.startYear = _data['startYear'];
        this.startDayOfWeek = _data['startDayOfWeek'];
        this.startTime = _data['startTime'];
        this.endTime = _data['endTime'];
        this.durationDays = _data['durationDays'];
        this.connectedTimeSec = _data['connectedTimeSec'];
        this.chargeTimeSec = _data['chargeTimeSec'];
        this.averagePower = _data['averagePower'];
        this.chargedEnergy = _data['chargedEnergy'];
        this.chargedDistance = _data['chargedDistance'];
        this.id = _data['id'];
        this.transactionId = _data['transactionId'];
        this.createdDate = _data['createdDate']
          ? new Date(_data['createdDate'].toString())
          : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['chargeControllerId'] = this.chargeControllerId;
      data['chargePointId'] = this.chargePointId;
      data['chargePointName'] = this.chargePointName;
      data['rfidTag'] = this.rfidTag;
      data['rfidName'] = this.rfidName;
      data['startDay'] = this.startDay;
      data['startMonth'] = this.startMonth;
      data['startYear'] = this.startYear;
      data['startDayOfWeek'] = this.startDayOfWeek;
      data['startTime'] = this.startTime;
      data['endTime'] = this.endTime;
      data['durationDays'] = this.durationDays;
      data['connectedTimeSec'] = this.connectedTimeSec;
      data['chargeTimeSec'] = this.chargeTimeSec;
      data['averagePower'] = this.averagePower;
      data['chargedEnergy'] = this.chargedEnergy;
      data['chargedDistance'] = this.chargedDistance;
      data['id'] = this.id;
      data['transactionId'] = this.transactionId;
      data['createdDate'] = this.createdDate
        ? this.createdDate.toISOString()
        : <any>undefined;
      return data;
    }
  }

  export interface ITransaction {
    chargeControllerId?: number;
    chargePointId?: number;
    chargePointName?: string;
    rfidTag?: string;
    rfidName?: string;
    startDay?: string;
    startMonth?: string;
    startYear?: string;
    startDayOfWeek?: string;
    startTime?: string;
    endTime?: string;
    durationDays?: string;
    connectedTimeSec?: number;
    chargeTimeSec?: number;
    averagePower?: number;
    chargedEnergy?: number;
    chargedDistance?: number;
    id?: number;
    transactionId?: number;
    createdDate?: Date | undefined;
  }

  export class Email implements IEmail {
    id?: number;
    ftype?: string;
    emailReceiver?: string;
    receiverName?: string;
    rfid?: string;

    constructor(data?: IEmail) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Email {
      data = typeof data === 'object' ? data : {};
      let result = new Email();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.ftype = _data['ftype'];
        this.emailReceiver = _data['emailReceiver'];
        this.receiverName = _data['receiverName'];
        this.rfid = _data['rfid'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['ftype'] = this.ftype;
      data['emailReceiver'] = this.emailReceiver;
      data['receiverName'] = this.receiverName;
      data['rfid'] = this.rfid;
      return data;
    }
  }

  export interface IEmail {
    id?: number;
    ftype?: string;
    emailReceiver?: string;
    receiverName?: string;
    rfid?: string;
  }

  export class Anonymous implements IAnonymous {
    ocppConfig?: OcppConfig;
    ocppStatus?: OcppStatus[];
    ocppMessages?: OcppMessage[];

    constructor(data?: IAnonymous) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Anonymous {
      data = typeof data === 'object' ? data : {};
      let result = new Anonymous();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.ocppConfig = _data['ocppConfig']
          ? OcppConfig.fromJS(_data['ocppConfig'])
          : <any>undefined;
        if (Array.isArray(_data['ocppStatus'])) {
          this.ocppStatus = [] as any;
          for (let item of _data['ocppStatus'])
            this.ocppStatus!.push(OcppStatus.fromJS(item));
        }
        if (Array.isArray(_data['ocppMessages'])) {
          this.ocppMessages = [] as any;
          for (let item of _data['ocppMessages'])
            this.ocppMessages!.push(OcppMessage.fromJS(item));
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['ocppConfig'] = this.ocppConfig
        ? this.ocppConfig.toJSON()
        : <any>undefined;
      if (Array.isArray(this.ocppStatus)) {
        data['ocppStatus'] = [];
        for (let item of this.ocppStatus)
          data['ocppStatus'].push(item.toJSON());
      }
      if (Array.isArray(this.ocppMessages)) {
        data['ocppMessages'] = [];
        for (let item of this.ocppMessages)
          data['ocppMessages'].push(item.toJSON());
      }
      return data;
    }
  }

  export interface IAnonymous {
    ocppConfig?: OcppConfig;
    ocppStatus?: OcppStatus[];
    ocppMessages?: OcppMessage[];
  }

  export class Anonymous2 implements IAnonymous2 {
    commandsHistoryList?: CommandHistory[];
    chargeController?: ChargeController;

    constructor(data?: IAnonymous2) {
      if (data) {
        for (let property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): Anonymous2 {
      data = typeof data === 'object' ? data : {};
      let result = new Anonymous2();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        if (Array.isArray(_data['commandsHistoryList'])) {
          this.commandsHistoryList = [] as any;
          for (let item of _data['commandsHistoryList'])
            this.commandsHistoryList!.push(CommandHistory.fromJS(item));
        }
        this.chargeController = _data['chargeController']
          ? ChargeController.fromJS(_data['chargeController'])
          : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.commandsHistoryList)) {
        data['commandsHistoryList'] = [];
        for (let item of this.commandsHistoryList)
          data['commandsHistoryList'].push(item.toJSON());
      }
      data['chargeController'] = this.chargeController
        ? this.chargeController.toJSON()
        : <any>undefined;
      return data;
    }
  }

  export interface IAnonymous2 {
    commandsHistoryList?: CommandHistory[];
    chargeController?: ChargeController;
  }

  export enum CommandType {
    SaveChargingPoint = 'SaveChargingPoint',
    EnableDisableChargePoint = 'EnableDisableChargePoint',
    RestartLM = 'RestartLM',
    RestartJC = 'RestartJC',
    RestartMS = 'RestartMS',
    RestartMB = 'RestartMB',
    RestartOCPP = 'RestartOCPP',
    RestartCA = 'RestartCA',
    RestartSM = 'RestartSM',
    RestartWEB = 'RestartWEB',
    ImportRFIDs = 'ImportRFIDs',
    EditRFID = 'EditRFID',
    OcppConfig = 'OcppConfig',
    ModemConfig = 'ModemConfig',
    NetworkConfig = 'NetworkConfig',
    RestartApp = 'RestartApp',
    DeleteRFID = 'DeleteRFID',
    DeleteAllRFIDs = 'DeleteAllRFIDs',
    SaveLoadManagement = 'SaveLoadManagement',
  }

  export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;
    protected isApiException = true;

    constructor(
      message: string,
      status: number,
      response: string,
      headers: { [key: string]: any },
      result: any
    ) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
    }

    static isApiException(obj: any): obj is ApiException {
      return obj.isApiException === true;
    }
  }

  function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
  ): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
  }
}
